
import torch.nn as nn
from torch.utils.data import Dataset
import torch.utils.data
import math
import pandas as pd
from torch.nn.utils.rnn import pad_sequence
from transformers import BertTokenizerFast
tokenizer = BertTokenizerFast.from_pretrained("bert-base-uncased")
import torch
from torch.utils.data import Dataset, DataLoader
import torch.nn.functional as F
import math
import triton
import triton.language as tl
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


max_len = 128
d_model = 256
heads = 8
num_layers =4
epochs = 2
Batch=16


def create_masks(question, reply_input, reply_target):
    def subsequent_mask(size):
        mask = torch.triu(torch.ones(size, size)).transpose(0, 1).type(dtype=torch.uint8)
        return mask.unsqueeze(0)
    question_mask = question != 0
    question_mask = question_mask.to(device)
    question_mask = question_mask.unsqueeze(1).unsqueeze(1)  # (batch_size, 1, 1, max_words)
    reply_input_mask = reply_input != 0
    reply_input_mask = reply_input_mask.unsqueeze(1)  # (batch_size, 1, max_words)
    reply_input_mask = reply_input_mask & subsequent_mask(reply_input.size(-1)).type_as(reply_input_mask.data)
    reply_input_mask = reply_input_mask.unsqueeze(1)  # (batch_size, 1, max_words, max_words)
    reply_target_mask = reply_target != 0  # (batch_size, max_words)
    return question_mask, reply_input_mask, reply_target_mask


class Embeddings(nn.Module):
    """
    Implements embeddings of the words and adds their positional encodings.
    """

    def __init__(self, vocab_size, d_model, max_len=128, num_layers=3):
        super(Embeddings, self).__init__()
        self.d_model = d_model
        self.dropout = nn.Dropout(0.1)
        self.embed = nn.Embedding(vocab_size, d_model)
        self.pe = self.create_positinal_encoding(max_len, self.d_model)  # (1, max_len, d_model)
        self.te = self.create_positinal_encoding(num_layers, self.d_model)  # (1, num_layers, d_model)
        self.dropout = nn.Dropout(0.1)

    def create_positinal_encoding(self, max_len, d_model):
        pe = torch.zeros(max_len, d_model).to(device)
        for pos in range(max_len):  # for each position of the word
            for i in range(0, d_model, 2):  # for each dimension of the each position
                pe[pos, i] = math.sin(pos / (10000 ** ((2 * i) / d_model)))
                pe[pos, i + 1] = math.cos(pos / (10000 ** ((2 * (i + 1)) / d_model)))
        pe = pe.unsqueeze(0)  # include the batch size
        return pe
    def forward(self, embedding, layer_idx):
        if layer_idx == 0:
            embedding = self.embed(embedding) * math.sqrt(self.d_model)
        embedding += self.pe[:,
                     :embedding.size(1)]  # pe will automatically be expanded with the same batch size as encoded_words
        # embedding: (batch_size, max_len, d_model), te: (batch_size, 1, d_model)
        embedding += self.te[:, layer_idx, :].unsqueeze(1).repeat(1, embedding.size(1), 1)
        embedding = self.dropout(embedding)
        return embedding



@triton.jit
def attention_tile_kernel(
    Q_ptr, K_ptr, V_ptr,
    out_ptr,
    N, D, num_tiles,
    TILE_N: tl.constexpr, TILE_D: tl.constexpr, CHUNK_D: tl.constexpr
):
    pid_bh = tl.program_id(0)  # batch*head
    pid_tq = tl.program_id(1)  # tile along sequence N

    # -------------------------------
    # Compute row indices for this til
    # -------------------------------
    start_q = pid_tq * TILE_N
    rn = start_q + tl.arange(0, TILE_N)[:, None]  # (TILE_N,1)
    cd = tl.arange(0, TILE_D)[None, :]            # (1, TILE_D)
    q_mask = (rn < N) & (cd < D)

    # -------------------------------
    # Step 1 & 2: Load Q/K tiles and compute Q@Kᵀ
    # -------------------------------
    acc = tl.zeros((TILE_N, TILE_N), dtype=tl.float32)

    for d_off in range(0, TILE_D, CHUNK_D):
        cd_sub = d_off + tl.arange(0, CHUNK_D)[None, :]
        mask_sub = (rn < N) & (cd_sub < D)

        q_sub = tl.load(Q_ptr + pid_bh * N * D + rn * D + cd_sub, mask=mask_sub, other=0.0).to(tl.float16)
        k_sub = tl.load(K_ptr + pid_bh * N * D + rn * D + cd_sub, mask=mask_sub, other=0.0).to(tl.float16)

        q_f32 = q_sub.to(tl.float32)
        k_f32 = k_sub.to(tl.float32)

        partial = tl.sum(q_f32[:, None, :] * k_f32[None, :, :], axis=2)
        # partial = tl.sum((q_sub[:, None, :] * k_sub[None, :, :]).to(tl.float32), axis=2)

        acc += partial
    # acc = acc.to(tl.float32)

    # -------------------------------
    # Step 3: Online row-wise softma
    # ------------------------------
    row_max = tl.max(acc, axis=1)
    exp_tile = tl.exp(acc - row_max[:, None])
    row_sum = tl.sum(exp_tile, axis=1)
    softmax_tile = exp_tile / row_sum[:, None]  # shape (TILE_N, TILE_N)

    # -------------------------------
    # Step 4: Multiply with V
    # -------------------------------
    # accumulator for output tile
    out_tile = tl.zeros((TILE_N, TILE_D), dtype=tl.float32)

    for d_off in range(0, D, CHUNK_D):
        cd_sub = d_off + tl.arange(0, CHUNK_D)[None, :]
        mask_sub = (rn < N) & (cd_sub < D)

        v_sub = tl.load(V_ptr + pid_bh * N * D + rn * D + cd_sub, mask=mask_sub, other=0.0).to(tl.float16)
        v_f32 = v_sub.to(tl.float32)  # (TILE_N, CHUNK_D)

        # Multiply softmax_tile (TILE_N × TILE_N) with V_chunk (TILE_N × CHUNK_D)
        # Result: TILE_N × CHUNK_D
        out_tile += tl.dot(softmax_tile, v_f32)  # Triton supports dot on small tiles

    # out_tile = out_tile.to(tl.float32)

    # -------------------------------
    # Store final output tile
    # -------------------------------
    out_idx = pid_bh * num_tiles * TILE_N * D \
             + pid_tq * TILE_N * D \
             + rn * D + cd  # linear offsets
    mask_out = (rn < N) & (cd < D)
    # tl.store(out_ptr + out_idx, out_tile, mask=mask_out)
    tl.store(out_ptr + out_idx, out_tile.to(tl.float16), mask=mask_out)


def flashattention_triton(q_tf, k_tf, v_tf, TILE_N=16, TILE_D=16, CHUNK_D=16):
    """
    q_tf, k_tf, v_tf : TensorFlow tensors with shape (B, H, N, D) and dtype float16 (or convertible)
    Returns TensorFlow tensor with shape (B, H, N, D) dtype float32 (matches kernel stores).
    """
    # print("r1")

    # Convert TF -> NumPy -> Torch (CUDA). Keep dtype consistent
    q = q_tf.to(device="cuda", dtype=torch.float16).contiguous()
    k = k_tf.to(device="cuda", dtype=torch.float16).contiguous()
    v = v_tf.to(device="cuda", dtype=torch.float16).contiguous()
    # q = torch.as_tensor(q_tf.numpy(), device='cuda').to(dtype=torch.float16)
    # k = torch.as_tensor(k_tf.numpy(), device='cuda').to(dtype=torch.float16)
    # v = torch.as_tensor(v_tf.numpy(), device='cuda').to(dtype=torch.float16)
    # q = torch.utils.dlpack.from_dlpack(tf.experimental.dlpack.to_dlpack(q_tf)).to(dtype=torch.float16).contiguous()
    # k = torch.utils.dlpack.from_dlpack(tf.experimental.dlpack.to_dlpack(k_tf)).to(dtype=torch.float16).contiguous()
    # v = torch.utils.dlpack.from_dlpack(tf.experimental.dlpack.to_dlpack(v_tf)).to(dtype=torch.float16).contiguous()
    # print("r2")
  
    B, H, N, D = q.shape
    BH = B * H

    num_tiles = (N + TILE_N - 1) // TILE_N
    padded_N = num_tiles * TILE_N   # may be >= N

    # Flatten B*H and pad sequence length if needed
    # print("r3")

    q_flat = q.reshape(BH, N, D)
    k_flat = k.reshape(BH, N, D)
    v_flat = v.reshape(BH, N, D)
    # print("v shape")
    # print(k_flat.shape)
    # print(v_flat.shape)

    # print("r4")
 

    # If padded_N > N, we must creat padded tensors (kernel reads up to rn < N via mask, so reading outside bounds is avoided,
    # but easier to pass tensors with shape (BH, padded_N, D) so store layout matches)
    if padded_N != N:
        # create padded views with zeros for rows N..padded_N-1
        q_pad = torch.zeros((BH, padded_N, D), device='cuda', dtype=q_flat.dtype)
        k_pad = torch.zeros((BH, padded_N, D), device='cuda', dtype=k_flat.dtype)
        v_pad = torch.zeros((BH, padded_N, D), device='cuda', dtype=v_flat.dtype)
        q_pad[:, :N, :] = q_flat
        k_pad[:, :N, :] = k_flat
        v_pad[:, :N, :] = v_flat
        q_flat = q_pad
        k_flat = k_pad
        v_flat = v_pad
    else:
        # ensure contiguous
        q_flat = q_flat.contiguous()
        k_flat = k_flat.contiguous()
        v_flat = v_flat.contiguous()

    # print("r5")


    # Allocate output as (BH, padded_N, D) in float32 (kernel stores float32
    # out_flat = torch.zeros((BH, padded_N, D), device='cuda', dtype=torch.float16, requires_grad=False).contiguous()
    out_flat = torch.zeros((BH, padded_N, D), device='cuda', dtype=torch.float32, requires_grad=False).contiguous()

    # print("r6")
    grid = (BH, num_tiles)

    # Call Triton kernel.
    # NOTE: attention_tile_kernel must be the Triton function you posted earlier (or the corrected chunking version).
    # Triton accepts torch tensors as args and will get underlying pointers automatically.
    attention_tile_kernel[grid](
        q_flat, k_flat, v_flat,
        out_flat,
        N, D, num_tiles,
        TILE_N, TILE_D, CHUNK_D
    )

    out_torch = out_flat[:, :N].reshape(B, H, N, D).contiguous()
    return out_torch  # NOW returning Py

    return out_tf

class MultiHeadAttention(nn.Module):
    def __init__(self, heads, d_model):
        super(MultiHeadAttention, self).__init__()
        assert d_model % heads == 0
        self.d_k = d_model // heads
        self.heads = heads
        self.dropout = nn.Dropout(0.1)
        self.query = nn.Linear(d_model, d_model)
        self.key = nn.Linear(d_model, d_model)
        self.value = nn.Linear(d_model, d_model)
        self.concat = nn.Linear(d_model, d_model)

    def forward(self, query, key, value, mask=None):
        # query/key/value: (B, seq_len, d_model) float32 by default
        B = query.shape[0]

        # Linear projections (stay in float32)
        q = self.query(query)
        k = self.key(key)
        v = self.value(value)

        # Reshape to (B, H, N, D)
        q = q.view(B, -1, self.heads, self.d_k).permute(0, 2, 1, 3).contiguous()
        k = k.view(B, -1, self.heads, self.d_k).permute(0, 2, 1, 3).contiguous()
        v = v.view(B, -1, self.heads, self.d_k).permute(0, 2, 1, 3).contiguous()

        # Call flashattention (requires float16/bf16 for best perf). We'll pass fp16 but convert back after.
        attn_out = flashattention_triton(q, k, v, TILE_N=16, TILE_D=16, CHUNK_D=16)
        # attn_out: (B, H, N, D) dtype=float16

        # Convert to float32 for the linear concat
        attn_out = attn_out.float()

        # Merge heads: (B, N, H*D)
        context = attn_out.permute(0, 2, 1, 3).contiguous().view(B, -1, self.heads * self.d_k)

        # Final linear
        out = self.concat(context)
        return out



class FeedForward(nn.Module):
    def __init__(self, d_model, middle_dim=2048):
            super(FeedForward, self).__init__()
            self.fc1 = nn.Linear(d_model, middle_dim)
            self.fc2 = nn.Linear(middle_dim, d_model)
            self.dropout = nn.Dropout(0.1)

    def forward(self, x):
            out = F.relu(self.fc1(x))
            out = self.fc2(self.dropout(out))
            return out

class EncoderLayer(nn.Module):
    def __init__(self, d_model, heads):
        super(EncoderLayer, self).__init__()
        self.layernorm = nn.LayerNorm(d_model)
        self.self_multihead = MultiHeadAttention(heads, d_model)
        self.feed_forward = FeedForward(d_model)
        self.dropout = nn.Dropout(0.1)

    def forward(self, embeddings, mask):
        interacted = self.dropout(self.self_multihead(embeddings, embeddings, embeddings, mask))
        interacted = self.layernorm(interacted + embeddings)
        feed_forward_out = self.dropout(self.feed_forward(interacted))
        encoded = self.layernorm(feed_forward_out + interacted)
        return encoded


class DecoderLayer(nn.Module):
    def __init__(self, d_model, heads):
        super(DecoderLayer, self).__init__()
        self.layernorm = nn.LayerNorm(d_model)
        self.self_multihead = MultiHeadAttention(heads, d_model)
        self.src_multihead = MultiHeadAttention(heads, d_model)
        self.feed_forward = FeedForward(d_model)
        self.dropout = nn.Dropout(0.1)
    def forward(self, embeddings, encoded, src_mask, target_mask):
        query = self.dropout(self.self_multihead(embeddings, embeddings, embeddings, target_mask))
        query = self.layernorm(query + embeddings)
        interacted = self.dropout(self.src_multihead(query, encoded, encoded, src_mask))
        interacted = self.layernorm(interacted + query)
        feed_forward_out = self.dropout(self.feed_forward(interacted))
        decoded = self.layernorm(feed_forward_out + interacted)
        return decoded


class Transformer(nn.Module):
    def __init__(self, d_model, heads, num_layers, word_map):
        super(Transformer, self).__init__()
        self.d_model = d_model
        self.num_layers = num_layers
        self.vocab_size = len(word_map)
        self.embed = Embeddings(self.vocab_size, d_model, num_layers=num_layers)
        self.encoder = EncoderLayer(d_model, heads)
        self.decoder = DecoderLayer(d_model, heads)
        self.logit = nn.Linear(d_model, self.vocab_size)

    def encode(self, src_embeddings, src_mask):
        for i in range(self.num_layers):
            src_embeddings = self.embed(src_embeddings, i)
            src_embeddings = self.encoder(src_embeddings, src_mask)
        return src_embeddings

    def decode(self, tgt_embeddings, target_mask, src_embeddings, src_mask):
        for i in range(self.num_layers):
            tgt_embeddings = self.embed(tgt_embeddings, i)
            # print("embeddings")
            # print(tgt_embeddings)
            tgt_embeddings = self.decoder(tgt_embeddings, src_embeddings, src_mask, target_mask)
        return tgt_embeddings

    def forward(self, src_words, src_mask, target_words, target_mask):
        encoded = self.encode(src_words, src_mask)
        decoded = self.decode(target_words, target_mask, encoded, src_mask)
        out = F.log_softmax(self.logit(decoded), dim=2)
        return out

class AdamWarmup:
    def __init__(self, model_size, warmup_steps, optimizer):
        self.model_size = model_size
        self.warmup_steps = warmup_steps
        self.optimizer = optimizer
        self.current_step = 0
        self.lr = 0

    def get_lr(self):
        return self.model_size ** (-0.5) * min(self.current_step ** (-0.5),
                                               self.current_step * self.warmup_steps ** (-1.5))
    def step(self):
        # Increment the number of steps each time we call the step function
        self.current_step += 1
        lr = self.get_lr()
        for param_group in self.optimizer.param_groups:
            param_group['lr'] = lr
        # update the learning rate
        self.lr = lr
        self.optimizer.step()


class LossWithLS(nn.Module):
    def __init__(self, size, smooth):
        super(LossWithLS, self).__init__()
        self.criterion = nn.KLDivLoss(reduction='none')  # Use reduction='none' instead of size_average=False, reduce=False
        self.confidence = 1.0 - smooth
        self.smooth = smooth
        self.size = size

    def forward(self, prediction, target, mask):
        # """
        # prediction of shape: (batch_size, max_words, vocab_size)
        # target and mask of shape: (batch_size, max_words)
        # """
        # prediction = prediction.view(-1, prediction.size(-1))  # (batch_size * max_words, vocab_size)
        # target = target.contiguous().view(-1)  # (batch_size * max_words)
        # mask = mask.float().view(-1)

        # labels = torch.full_like(prediction, self.smooth / (self.size - 1))
        # labels.scatter_(1, target.unsqueeze(1), self.confidence)

        # loss = self.criterion(prediction, labels)  # (batch_size * max_words, vocab_size)
        # loss = (loss.sum(1) * mask).sum() / mask.sum()

        # return loss
        """
        pred   : (batch*seq_len, vocab)
        target : (batch*seq_len)
        """
        mask = (target < 0) | (target >= self.size)  # mask invalid targets
        target = target.clone()
        target[mask] = 0  # temporary dummy index
    
        # Create smoothed distribution
        true_dist = pred.clone()
        true_dist.fill_(self.smooth / (self.size - 1))
        true_dist.scatter_(1, target.data.unsqueeze(1), self.confidence)
        true_dist[mask] = 0
    
        return self.criterion(pred, true_dist).sum()

# import torch
# import torch.nn.functional as F

# # Ensure device
# device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# # 1. Sample data (16 sentences to match batch size)
# sample_questions = [
#     "Hello world!", "How are you?", "Transformers are cool.", "I like pizza.",
#     "Today is sunny.", "PyTorch is fun.", "Let's test this model.", "OpenAI makes GPT models.",
#     "ChatGPT can help.", "This is a transformer test.", "I enjoy coding.", "Deep learning is powerful.",
#     "BERT tokenizer works well.", "Testing batch processing.", "Sequence modeling is useful.", "End-to-end test."
# ]

# sample_replies = [
#     "Hi!", "I'm fine, thanks.", "Yes, indeed!", "Me too.", 
#     "Enjoy the sun.", "Absolutely!", "Let's see.", "Definitely.", 
#     "Sure!", "It works.", "I agree.", "Very true.", 
#     "Works perfectly.", "All good.", "Very useful.", "Done."
# ]

# # 2. Tokenize with BERT tokenizer
# encoded_questions = tokenizer(
#     sample_questions, padding='max_length', truncation=True, 
#     max_length=max_len, return_tensors='pt'
# )
# encoded_replies = tokenizer(
#     sample_replies, padding='max_length', truncation=True, 
#     max_length=max_len, return_tensors='pt'
# )

# # 3. Move all token tensors to device
# question_ids = encoded_questions['input_ids'].to(device)

# # Decoder input: remove last token, then pad to max_len if needed
# reply_input_ids = encoded_replies['input_ids'][:, :-1].to(device)
# # Ensure length matches max_len for flash attention
# if reply_input_ids.size(1) < max_len:
#     pad_len = max_len - reply_input_ids.size(1)
#     reply_input_ids = F.pad(reply_input_ids, (0, pad_len), value=tokenizer.pad_token_id)

# # Decoder target: remove first token
# reply_target_ids = encoded_replies['input_ids'][:, 1:].to(device)
# if reply_target_ids.size(1) < max_len:
#     pad_len = max_len - reply_target_ids.size(1)
#     reply_target_ids = F.pad(reply_target_ids, (0, pad_len), value=tokenizer.pad_token_id)

# # 4. Create masks
# q_mask, reply_input_mask, reply_target_mask = create_masks(
#     question_ids, reply_input_ids, reply_target_ids
# )

# # 5. Initialize transformer
# dummy_vocab = tokenizer.get_vocab()
# model = Transformer(d_model=d_model, heads=heads, num_layers=num_layers, word_map=dummy_vocab).to(device)

# # 6. Forward pass
# outputs = model(question_ids, q_mask, reply_input_ids, reply_input_mask)

# print("Output shape:", outputs.shape)  # should be (16, max_len, vocab_size)
# print("Sample output (first 5 tokens of first batch):", outputs[0, :5, :10])

#----------------------------Bert------------------------------------------------

# import torch
# import torch.nn.functional as F
# import pandas as pd
# from transformers import BertTokenizerFast

# # Ensure device
# device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# # Load BERT tokenizer
# tokenizer = BertTokenizerFast.from_pretrained("bert-base-uncased")

# # Max sequence length
# max_len = 128  # same as your transformer setting

# # -----------------------------
# # 1. Load data from CSV
# # -----------------------------
# df = pd.read_csv("/kaggle/input/news-summarization/data.csv")

# # Make sure columns exist
# assert 'Content' in df.columns and 'Summary' in df.columns, "CSV must have 'Content' and 'Summary' columns"

# # For demo purposes, select first 16 examples (adjust batch size accordingly)
# df = df.head(16)

# contents = df['Content'].tolist()
# summaries = df['Summary'].tolist()

# # -----------------------------
# # 2. Tokenize with BERT tokenizer
# # -----------------------------
# encoded_questions = tokenizer(
#     contents,
#     padding='max_length',
#     truncation=True,
#     max_length=max_len,
#     return_tensors='pt'
# )

# encoded_replies = tokenizer(
#     summaries,
#     padding='max_length',
#     truncation=True,
#     max_length=max_len,
#     return_tensors='pt'
# )



# question_ids = encoded_questions['input_ids'].to(device)

# # # Decoder input: remove last token, pad if needed
# reply_input_ids = encoded_replies['input_ids'][:, :-1].to(device)
# if reply_input_ids.size(1) < max_len:
#     pad_len = max_len - reply_input_ids.size(1)
#     reply_input_ids = F.pad(reply_input_ids, (0, pad_len), value=tokenizer.pad_token_id)

# # Decoder target: remove first token, pad if needed
# reply_target_ids = encoded_replies['input_ids'][:, 1:].to(device)
# if reply_target_ids.size(1) < max_len:
#     pad_len = max_len - reply_target_ids.size(1)
#     reply_target_ids = F.pad(reply_target_ids, (0, pad_len), value=tokenizer.pad_token_id)

# # print(reply_target_ids)
# # # -----------------------------
# # # 4. Create masks
# # # -----------------------------
# q_mask, reply_input_mask, reply_target_mask = create_masks(
#     question_ids, reply_input_ids, reply_target_ids
# )

# # # -----------------------------
# # # 5. Initialize transformer
# # # -----------------------------
# dummy_vocab = tokenizer.get_vocab()
# model = Transformer(d_model=d_model, heads=heads, num_layers=num_layers, word_map=dummy_vocab).to(device)

# # # -----------------------------
# # # 6. Forward pass
# # # -----------------------------
# outputs = model(question_ids, q_mask, reply_input_ids, reply_input_mask)

# print("Output shape:", outputs.shape)  # should be (16, max_len, vocab_size)
# print("Sample output (first 5 tokens of first batch):", outputs[0, :5, :10])
#----------------------------------------------------------------------------------


#---------------------------Bert -ec----------------------------------

import torch
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader
import pandas as pd

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


# ================================================
# 1. LOAD CSV (1000 samples)
# ================================================
df = pd.read_csv("/kaggle/input/news-summarization/data.csv").head(16)

contents  = df["Content"].astype(str).tolist()
summaries = df["Summary"].astype(str).tolist()


# ================================================
# 2. CUSTOM DATASET
# ================================================
class TextSummaryDataset(Dataset):
    def __init__(self, contents, summaries, tokenizer, max_len):
        self.contents = contents
        self.summaries = summaries
        self.tokenizer = tokenizer
        self.max_len = max_len
        self.pad = tokenizer.pad_token_id

    def __len__(self):
        return len(self.contents)

    def __getitem__(self, idx):
        content = self.contents[idx]
        summary = self.summaries[idx]

        # Encode input (Content)
        enc = self.tokenizer(
            content,
            padding='max_length', truncation=True,
            max_length=self.max_len,
            return_tensors='pt'
        )

        # Encode output (Summary)
        dec = self.tokenizer(
            summary,
            padding='max_length', truncation=True,
            max_length=self.max_len,
            return_tensors='pt'
        )

        # Tensors are shape (1, max_len) → remove dimension
        input_ids = enc['input_ids'].squeeze(0)
        summary_ids = dec['input_ids'].squeeze(0)

        # Decoder input (shift right)
        reply_input_ids = summary_ids[:-1]
        reply_input_ids = F.pad(reply_input_ids,
                                (0, self.max_len - reply_input_ids.size(0)),
                                value=self.pad)

        # Decoder target (shift left)
        reply_target_ids = summary_ids[1:]
        reply_target_ids = F.pad(reply_target_ids,
                                 (0, self.max_len - reply_target_ids.size(0)),
                                 value=self.pad)

        return {
            "question_ids": input_ids,
            "reply_input_ids": reply_input_ids,
            "reply_target_ids": reply_target_ids
        }


# ================================================
# 3. DATALOADER
# ================================================
dataset = TextSummaryDataset(contents, summaries, tokenizer, max_len)
loader = DataLoader(dataset, batch_size=16, shuffle=True)

print(loader)
# ================================================
# 4. INITIALIZE MODEL
# ================================================
dummy_vocab = tokenizer.get_vocab()
loss_fn = LossWithLS(size=dummy_vocab, smooth=0.1)

model = Transformer(
    d_model=d_model,
    heads=heads,
    num_layers=num_layers,
    word_map=dummy_vocab
).to(device)

optimizer = torch.optim.Adam(model.parameters(), lr=2e-4)
loss_fn = torch.nn.CrossEntropyLoss(ignore_index=tokenizer.pad_token_id)


# ================================================
# 5. TRAINING LOOP (10 epochs)
# ================================================
for epoch in range(2):

    model.train()
    total_loss = 0

    for batch in loader:

        question_ids = batch["question_ids"].to(device)
        reply_input_ids = batch["reply_input_ids"].to(device)
        reply_target_ids = batch["reply_target_ids"].to(device)

        reply_target_ids_masked = reply_target_ids.clone()
        reply_target_ids_masked[reply_target_ids_masked == tokenizer.pad_token_id] = -100

        # Create masks
        q_mask, reply_input_mask, reply_target_mask = create_masks(
            question_ids, reply_input_ids, reply_target_ids
        )
        print("question_ids:", question_ids.shape, question_ids.dtype, question_ids.min(), question_ids.max())
        print("reply_input_ids:", reply_input_ids.shape, reply_input_ids.dtype, reply_input_ids.min(), reply_input_ids.max())
        print("reply_target_ids:", reply_target_ids.shape, reply_target_ids.dtype, reply_target_ids.min(), reply_target_ids.max())
        

        optimizer.zero_grad()

        # Forward pas
        outputs = model(question_ids, q_mask, reply_input_ids, reply_input_mask)

        # Reshape for CE loss
        vocab_size = outputs.size(-1)
        # loss = loss_fn(
        #     outputs.reshape(-1, vocab_size),
        #     reply_target_ids.reshape(-1)
        # )
        logits = F.log_softmax(outputs, dim=-1).reshape(-1, vocab_size)
        targets = reply_target_ids_masked.reshape(-1)
        loss = loss_fn(logits, targets)


        loss.backward()
        optimizer.step()

        total_loss += loss.item()

    print(f"Epoch {epoch+1}/10   Loss: {total_loss:.4f}")


print("Training complete.")
