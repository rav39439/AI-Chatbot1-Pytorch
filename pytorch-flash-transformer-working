
source:
https://github.com/hkproj/triton-flash-attention?utm_source=chatgpt.com
https://github.com/Dao-AILab/flash-attention/blob/main/flash_attn/flash_attn_triton.py

# transformer_triton_flash_attention.txt
# Minimal GPT-style Transformer using custom Triton Flash Attention
# ================================================================

import torch
import torch.nn as nn
import math

import torch

import triton
import triton.language as tl


@triton.jit
def _attn_fwd_inner(
    O_block,
    l_i,
    m_i,
    Q_block,
    K_block_ptr,
    V_block_ptr,
    block_index_q,
    softmax_scale,
    BLOCK_SIZE_Q: tl.constexpr,
    BLOCK_SIZE_KV: tl.constexpr,
    STAGE: tl.constexpr,
    offs_q: tl.constexpr,
    offs_kv: tl.constexpr,
    SEQ_LEN: tl.constexpr,
):
    # range of values handled by this stage
    if STAGE == 1:
        # From 0 to the left of the diagonal
        lo, hi = 0, block_index_q * BLOCK_SIZE_Q
    elif STAGE == 2:
        # Used only for the block in which there is transition between non-masked and masked keys
        lo, hi = block_index_q * BLOCK_SIZE_Q, (block_index_q + 1) * BLOCK_SIZE_Q
        lo = tl.multiple_of(lo, BLOCK_SIZE_Q)
    else:
        # Only used for non-causal attention
        lo, hi = 0, SEQ_LEN

    K_block_ptr = tl.advance(K_block_ptr, (0, lo))
    V_block_ptr = tl.advance(V_block_ptr, (lo, 0))

    # loop over k, v and update accumulator
    for start_kv in range(lo, hi, BLOCK_SIZE_KV):
        # Just let the compiler know that start_n is a multiple of BLOCK_N, so the compiler can do optimizations
        start_kv = tl.multiple_of(start_kv, BLOCK_SIZE_KV)

        # -- compute qk ----
        K_block = tl.load(K_block_ptr)
        QK_block = tl.dot(Q_block, K_block)

        if STAGE == 2:
            mask = offs_q[:, None] >= (start_kv + offs_kv[None, :])
            QK_block = QK_block * softmax_scale + tl.where(mask, 0, -1.0e6)
            m_ij = tl.maximum(m_i, tl.max(QK_block, 1))
            QK_block -= m_ij[:, None]
        else:
            # Compute the maximum value of qk or keep the old max value
            m_ij = tl.maximum(m_i, tl.max(QK_block, 1) * softmax_scale)
            QK_block = QK_block * softmax_scale - m_ij[:, None]

        # Compute the exponential of each dot product, so now we are computing exp(qk_ij - m_ij)
        P_block = tl.math.exp(QK_block)
        # Compute the sum by rows of the attention scores
        l_ij = tl.sum(P_block, 1)

        # This is the correction factor for the previous l_i
        alpha = tl.math.exp(m_i - m_ij)
        # Apply the correction factor to the previous l_i and add the new l_ij
        l_i = l_i * alpha + l_ij

        V_block = tl.load(V_block_ptr)
        P_block = P_block.to(tl.float16)
        # This computes the following: O_new = P x V + O_old * alpha
        O_block = O_block * alpha[:, None]
        O_block = tl.dot(P_block, V_block, O_block)

        m_i = m_ij

        # Move to the next block of K and V
        V_block_ptr = tl.advance(V_block_ptr, (BLOCK_SIZE_KV, 0))
        K_block_ptr = tl.advance(K_block_ptr, (0, BLOCK_SIZE_KV))
    return O_block, l_i, m_i


@triton.autotune(
    [
        triton.Config(
            {"BLOCK_SIZE_Q": BLOCK_SIZE_Q, "BLOCK_SIZE_KV": BLOCK_SIZE_KV},
            num_stages=num_stages,
            num_warps=num_warps,
        )
        for BLOCK_SIZE_Q in [64, 128]
        for BLOCK_SIZE_KV in [32, 64]
        for num_stages in ([3, 4, 7])
        for num_warps in [2, 4]
    ],
    key=["SEQ_LEN", "HEAD_DIM"],
)
@triton.jit
def _attn_fwd(
    Q,  # BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM
    K,  # BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM
    V,  # BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM
    softmax_scale,
    M,  # BATCH_SIZE, NUM_HEADS, SEQ_LEN
    O,  # BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM
    stride_Q_batch,
    stride_Q_head,
    stride_Q_seq,
    stride_Q_dim,
    stride_K_batch,
    stride_K_head,
    stride_K_seq,
    stride_K_dim,
    stride_V_batch,
    stride_V_head,
    stride_V_seq,
    stride_V_dim,
    stride_O_batch,
    stride_O_head,
    stride_O_seq,
    stride_O_dim,
    BATCH_SIZE,
    NUM_HEADS: tl.constexpr,
    SEQ_LEN: tl.constexpr,
    HEAD_DIM: tl.constexpr,
    BLOCK_SIZE_Q: tl.constexpr,
    BLOCK_SIZE_KV: tl.constexpr,
    STAGE: tl.constexpr,
):
    tl.static_assert(BLOCK_SIZE_KV <= HEAD_DIM)

    # This indicate which block in the sequence length to process
    block_index_q = tl.program_id(0)

    # This indicates which head and batch to process. Each program is associated with a single head of a single batch
    index_batch_head = tl.program_id(1)
    # This indicate which batch this program is associated with (each batch has NUM_HEADS heads)
    index_batch = index_batch_head // NUM_HEADS
    # This indicate the position of the head in the batch
    index_head = index_batch_head % NUM_HEADS

    # This allows to get the (N_CTX, HEAD_DIM) block in the Q, K, V by selecting indexing it by batch and head
    qvk_offset = (
        index_batch.to(tl.int64) * stride_Q_batch
        + index_head.to(tl.int64) * stride_Q_head
    )

    Q_block_ptr = tl.make_block_ptr(
        base=Q + qvk_offset,
        shape=(SEQ_LEN, HEAD_DIM),
        strides=(stride_Q_seq, stride_Q_dim),
        offsets=(block_index_q * BLOCK_SIZE_Q, 0),
        block_shape=(BLOCK_SIZE_Q, HEAD_DIM),
        order=(1, 0),
    )

    V_block_ptr = tl.make_block_ptr(
        base=V + qvk_offset,
        shape=(SEQ_LEN, HEAD_DIM),
        strides=(stride_V_seq, stride_V_dim),
        offsets=(0, 0),
        block_shape=(BLOCK_SIZE_KV, HEAD_DIM),
        order=(1, 0),
    )

    K_block_ptr = tl.make_block_ptr(
        base=K + qvk_offset,
        shape=(HEAD_DIM, SEQ_LEN),
        strides=(
            stride_K_dim,
            stride_K_seq,
        ),  # We invert the strides w.r.t Q, so we transpose the matrix
        offsets=(0, 0),
        block_shape=(HEAD_DIM, BLOCK_SIZE_KV),
        order=(0, 1),
    )

    O_block_ptr = tl.make_block_ptr(
        base=O + qvk_offset,
        shape=(SEQ_LEN, HEAD_DIM),
        strides=(stride_O_seq, stride_O_dim),
        offsets=(block_index_q * BLOCK_SIZE_Q, 0),
        block_shape=(BLOCK_SIZE_Q, HEAD_DIM),
        order=(1, 0),
    )

    # offs_q: the offsets for the tokens in the Q to process
    offs_q = block_index_q * BLOCK_SIZE_Q + tl.arange(0, BLOCK_SIZE_Q)
    # offs_kv: the offsets for the tokens in the K and V sequence to process
    offs_kv = tl.arange(0, BLOCK_SIZE_KV)

    # m_i: the running maximum. We have one for each query
    m_i = tl.zeros([BLOCK_SIZE_Q], dtype=tl.float32) - float("inf")
    # l_i: the running sum. We have one for each query (as we sum the attention scores by rows)
    l_i = tl.zeros([BLOCK_SIZE_Q], dtype=tl.float32) + 1.0
    # acc: the accumulator for the output, which is a group of rows of the O matrix
    O_block = tl.zeros([BLOCK_SIZE_Q, HEAD_DIM], dtype=tl.float32)

    # load the blocks of Q: it will stay in SRAM throughout
    Q_block = tl.load(Q_block_ptr)

    # Stage: 3 if causal, else 1

    if STAGE == 1 or STAGE == 3:
        # This step runs for non-causal attention or for the blocks to the left of the diagonal in the causal attention
        O_block, l_i, m_i = _attn_fwd_inner(
            O_block,
            l_i,
            m_i,
            Q_block,
            K_block_ptr,
            V_block_ptr,
            block_index_q,
            softmax_scale,
            BLOCK_SIZE_Q,
            BLOCK_SIZE_KV,
            4 - STAGE,
            offs_q,
            offs_kv,
            SEQ_LEN,
        )

    if STAGE == 3:
        # This step runs for the blocks to the right of the diagonal in the causal attention
        O_block, l_i, m_i = _attn_fwd_inner(
            O_block,
            l_i,
            m_i,
            Q_block,
            K_block_ptr,
            V_block_ptr,
            block_index_q,
            softmax_scale,
            BLOCK_SIZE_Q,
            BLOCK_SIZE_KV,
            2,
            offs_q,
            offs_kv,
            SEQ_LEN,
        )
    # epilogue
    m_i += tl.math.log(
        l_i
    )  # This is needed to compute the logsumexp for the backwards pass
    O_block = O_block / l_i[:, None]
    m_ptrs = M + index_batch_head * SEQ_LEN + offs_q
    tl.store(m_ptrs, m_i)
    tl.store(O_block_ptr, O_block.to(O.type.element_ty))


@triton.jit
def _attn_bwd_preprocess(
    O,
    dO,
    D,
    SEQ_LEN,
    BLOCK_SIZE_Q: tl.constexpr,
    HEAD_DIM: tl.constexpr,
):
    block_index_q = tl.program_id(0)
    offs_q = block_index_q * BLOCK_SIZE_Q + tl.arange(0, BLOCK_SIZE_Q)
    index_batch_head = tl.program_id(1)
    offs_dim = tl.arange(0, HEAD_DIM)
    # Load a single block of BLOCK_SIZE_Q rows of O
    O_block = tl.load(
        O
        + index_batch_head * HEAD_DIM * SEQ_LEN
        + offs_q[:, None] * HEAD_DIM
        + offs_dim[None, :]
    )
    # Load a single block of BLOCK_SIZE_Q rows of dO
    dO_block = tl.load(
        dO
        + index_batch_head * HEAD_DIM * SEQ_LEN
        + offs_q[:, None] * HEAD_DIM
        + offs_dim[None, :]
    ).to(tl.float32)
    # Compute the D block
    D_block = tl.sum(dO_block * O_block, axis=1)  # Shape: (BLOCK_SIZE_Q,)
    # Store the D block
    D_block_ptrs = D + index_batch_head * SEQ_LEN + offs_q
    tl.store(D_block_ptrs, D_block)


@triton.jit
def _attn_bwd_dq(
    Q,
    K,
    V,
    softmax_scale,
    dO,
    dQ,
    dK,
    dV,
    M,
    D,
    stride_batch,
    stride_head,
    stride_seq,
    stride_dim,
    NUM_HEADS,
    SEQ_LEN,
    BLOCK_Q: tl.constexpr,
    BLOCK_KV: tl.constexpr,
    HEAD_DIM: tl.constexpr,
    STAGE: tl.constexpr,
):
    index_batch_head = tl.program_id(2)
    index_batch = index_batch_head // NUM_HEADS
    index_head = index_batch_head % NUM_HEADS
    offset_batch_head = (stride_batch * index_batch + stride_head * index_head).to(
        tl.int64
    )
    # This is the offset that allows us to select the right sequence given the batch and head.
    offset_batch_head_seq = (index_batch_head * SEQ_LEN).to(tl.int64)

    # Make sure the pointers are in the right place w.r.t batch and head
    # The reason we don't access the blocks through make_block_ptr is because we need to use the range of offsets to apply the masking
    Q += offset_batch_head
    K += offset_batch_head
    V += offset_batch_head
    dO += offset_batch_head
    dQ += offset_batch_head
    dK += offset_batch_head
    dV += offset_batch_head

    # Make sure the pointers are in the right place w.r.t batch, head and sequence
    M += offset_batch_head_seq
    D += offset_batch_head_seq

    # load scales
    offs_dim = tl.arange(0, HEAD_DIM)

    index_block_kv = tl.program_id(0)

    start_q = index_block_kv * BLOCK_Q
    offs_q = start_q + tl.arange(0, BLOCK_Q)

    Q_block = tl.load(Q + offs_q[:, None] * stride_seq + offs_dim[None, :] * stride_dim)
    dQ_block = tl.zeros([BLOCK_Q, HEAD_DIM], dtype=tl.float32)
    dO_block = tl.load(
        dO + offs_q[:, None] * stride_seq + offs_dim[None, :] * stride_dim
    )

    M_block = tl.load(M + offs_q)
    M_block = M_block[:, None]

    offs_kv = tl.arange(0, BLOCK_KV)

    # We access the K and V as transposed blocks
    kT_ptrs = K + offs_kv[None, :] * stride_seq + offs_dim[:, None] * stride_dim
    vT_ptrs = V + offs_kv[None, :] * stride_seq + offs_dim[:, None] * stride_dim

    Di = tl.load(D + offs_q)

    curr_kv = 0
    num_steps = SEQ_LEN // BLOCK_KV
    for blk_idx in range(num_steps):
        K_T_block = tl.load(kT_ptrs)
        V_T_block = tl.load(vT_ptrs)
        QK_block = softmax_scale * tl.dot(Q_block, K_T_block)
        P_block = tl.math.exp(QK_block - M_block)

        if STAGE == 3:
            # Autoregressive masking.
            offs_kv = curr_kv + tl.arange(0, BLOCK_KV)
            mask_block = offs_q[:, None] >= offs_kv[None, :]
            P_block = tl.where(mask_block, P_block, 0.0)

        # Compute dP and dS.
        dP_block = tl.dot(dO_block, V_T_block).to(tl.float32)
        dS_block = P_block * (dP_block - Di[:, None])
        dS_block = dS_block.to(tl.float16)
        # Compute dQ.
        # NOTE: We need to de-scale dq in the end, because kT was pre-scaled.
        dQ_block += softmax_scale * tl.dot(dS_block, tl.trans(K_T_block))
        # Increment pointers.
        curr_kv += BLOCK_KV
        kT_ptrs += BLOCK_KV * stride_seq
        vT_ptrs += BLOCK_KV * stride_seq

    dQ_block_ptrs = dQ + offs_q[:, None] * stride_seq + offs_dim[None, :] * stride_dim
    tl.store(dQ_block_ptrs, dQ_block)


@triton.jit
def _attn_bwd_dk_dv(
    Q,
    K,
    V,
    softmax_scale,
    dO,
    dQ,
    dK,
    dV,
    M,
    D,
    stride_batch,
    stride_head,
    stride_seq,
    stride_dim,
    NUM_HEADS,
    SEQ_LEN,
    BLOCK_Q: tl.constexpr,
    BLOCK_KV: tl.constexpr,
    HEAD_DIM: tl.constexpr,
    STAGE: tl.constexpr,
):
    index_batch_head = tl.program_id(2)
    index_batch = index_batch_head // NUM_HEADS
    index_head = index_batch_head % NUM_HEADS
    offset_batch_head = (stride_batch * index_batch + stride_head * index_head).to(
        tl.int64
    )
    # This is the offset that allows us to select the right sequence given the batch and head.
    offset_batch_head_seq = (index_batch_head * SEQ_LEN).to(tl.int64)

    # Make sure the pointers are in the right place w.r.t batch and head
    # The reason we don't access the blocks through make_block_ptr is because we need to use the range of offsets to apply the masking
    Q += offset_batch_head
    K += offset_batch_head
    V += offset_batch_head
    dO += offset_batch_head
    dQ += offset_batch_head
    dK += offset_batch_head
    dV += offset_batch_head

    # Make sure the pointers are in the right place w.r.t batch, head and sequence
    M += offset_batch_head_seq
    D += offset_batch_head_seq

    # load scales
    offs_dim = tl.arange(0, HEAD_DIM)

    index_block_kv = tl.program_id(0)
    start_kv = index_block_kv * BLOCK_KV

    offs_kv = start_kv + tl.arange(0, BLOCK_KV)

    dV_block = tl.zeros([BLOCK_KV, HEAD_DIM], dtype=tl.float32)
    dK_block = tl.zeros([BLOCK_KV, HEAD_DIM], dtype=tl.float32)

    # load K and V: they stay in SRAM throughout the inner loop.
    K_block = tl.load(
        K + offs_kv[:, None] * stride_seq + offs_dim[None, :] * stride_dim
    )  # Shape: (BLOCK_KV1, HEAD_DIM)
    V_block = tl.load(
        V + offs_kv[:, None] * stride_seq + offs_dim[None, :] * stride_dim
    )  # Shape: (BLOCK_KV1, HEAD_DIM)

    offs_q = tl.arange(0, BLOCK_Q)

    # We access the Q as a transposed array, so that's why we treat offs_q as a column vector ans offs_dim as a row vector
    # This is equivalent to doing:
    # q_ptrs = Q + offs_q[:, None] * stride_seq + offs_dim[None, :] * stride_dim
    # qT_ptrs = tl.trans(q_ptrs)
    # We point to the first BLOCK_Q rows of Q for both the qT and dO pointers, inside the for loop we will move forward by BLOCK_Q rows at each iteration.
    qT_ptrs = Q + offs_q[None, :] * stride_seq + offs_dim[:, None] * stride_dim
    dO_ptrs = dO + offs_q[:, None] * stride_seq + offs_dim[None, :] * stride_dim

    # Iterates over the sequence dimension of the query
    curr_q = 0
    num_steps = SEQ_LEN // BLOCK_Q
    for blk_idx in range(num_steps):
        # Load a block of Q
        qT_block = tl.load(qT_ptrs)
        # Load the logsumexp values for the queries in the current block
        offs_q = curr_q + tl.arange(0, BLOCK_Q)
        m = tl.load(M + offs_q)

        # This gives us (QK^T)^T = (K^T)^T(Q^T) = K(Q^T) = P^T
        QK_T_block = softmax_scale * tl.dot(K_block, qT_block)
        # We apply the softmax by using the logsumexp trick
        P_T_block = tl.math.exp(QK_T_block - m[None, :])

        if STAGE == 3:
            # Autoregressive masking.
            # mask is True for all values that DO NOT NEED TO BE MASKED
            mask_block = (
                offs_q[None, :] >= offs_kv[:, None]
            )  # Shape: (BLOCK_KV1, BLOCK_Q1)
            # Replace all the masked values with 0.
            # In this case we do not need to mask with -Inf before applying the softmax since we already computed the normalization factors (stored in "m")
            P_T_block = tl.where(mask_block, P_T_block, 0.0)

        dO_block = tl.load(dO_ptrs)
        # According to the formula: dV_new = dV_old + P^T x dO, where x is the matrix multiplication
        dV_block += tl.dot(P_T_block.to(tl.float16), dO_block)

        # Delta = rowsum(O * dO) where * is the element-wise product
        Di = tl.load(D + offs_q)

        # dP = dO x V^T, so dP^T = V x dO^T
        # Where x is the matrix multiplication
        dpT_block = tl.dot(V_block, tl.trans(dO_block)).to(tl.float32)

        # We know that dS = P * (dP - Delta), so dS^T = P^T * (dP^T - Delta^T)

        dS_T_block = P_T_block * (dpT_block - Di[None, :])
        dS_T_block = dS_T_block.to(tl.float16)

        # According to the formula on the paper: dK_new = dK_old + dS^T x Q
        dK_block += softmax_scale * tl.dot(dS_T_block, tl.trans(qT_block))
        # Increment pointers.
        curr_q += BLOCK_Q
        qT_ptrs += BLOCK_Q * stride_seq
        dO_ptrs += BLOCK_Q * stride_seq

    # Write back dV.
    dV_block_ptrs = dV + offs_kv[:, None] * stride_seq + offs_dim[None, :] * stride_dim
    tl.store(dV_block_ptrs, dV_block)

    # Write back dK.
    dK_block_ptrs = dK + offs_kv[:, None] * stride_seq + offs_dim[None, :] * stride_dim
    tl.store(dK_block_ptrs, dK_block)


class TritonAttention(torch.autograd.Function):

    @staticmethod
    def forward(ctx, Q, K, V, causal, softmax_scale):
        HEAD_DIM_Q, HEAD_DIM_K = Q.shape[-1], K.shape[-1]
        HEAD_DIM_V = V.shape[-1]

        BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM = Q.shape

        assert HEAD_DIM_Q == HEAD_DIM_K and HEAD_DIM_K == HEAD_DIM_V

        O = torch.empty_like(Q)
        stage = 3 if causal else 1

        grid = lambda args: (
            triton.cdiv(SEQ_LEN, args["BLOCK_SIZE_Q"]),
            BATCH_SIZE * NUM_HEADS,
            1,
        )

        # M is the logsumexp for the backward pass, one for each query
        M = torch.empty(
            (BATCH_SIZE, NUM_HEADS, SEQ_LEN), device=Q.device, dtype=torch.float32
        )

        _attn_fwd[grid](
            Q=Q,
            K=K,
            V=V,
            softmax_scale=softmax_scale,
            M=M,
            O=O,
            stride_Q_batch=Q.stride(0),
            stride_Q_head=Q.stride(1),
            stride_Q_seq=Q.stride(2),
            stride_Q_dim=Q.stride(3),
            stride_K_batch=K.stride(0),
            stride_K_head=K.stride(1),
            stride_K_seq=K.stride(2),
            stride_K_dim=K.stride(3),
            stride_V_batch=V.stride(0),
            stride_V_head=V.stride(1),
            stride_V_seq=V.stride(2),
            stride_V_dim=V.stride(3),
            stride_O_batch=O.stride(0),
            stride_O_head=O.stride(1),
            stride_O_seq=O.stride(2),
            stride_O_dim=O.stride(3),
            BATCH_SIZE=Q.shape[0],
            NUM_HEADS=Q.shape[1],
            SEQ_LEN=Q.shape[2],
            HEAD_DIM=HEAD_DIM_K,
            STAGE=stage,
        )

        ctx.save_for_backward(Q, K, V, O, M)
        ctx.grid = grid
        ctx.softmax_scale = softmax_scale
        ctx.HEAD_DIM = HEAD_DIM_K
        ctx.causal = causal
        return O

    @staticmethod
    def backward(ctx, dO):
        Q, K, V, O, M = ctx.saved_tensors

        assert dO.is_contiguous()
        assert Q.stride() == K.stride() == V.stride() == O.stride() == dO.stride()
        dQ = torch.empty_like(Q)
        dK = torch.empty_like(K)
        dV = torch.empty_like(V)

        BATCH_SIZE, NUM_HEADS, SEQ_LEN = Q.shape[:3]
        NUM_WARPS, NUM_STAGES = 4, 3
        BLOCK_SIZE_MICRO, BLOCK_SIZE_MACRO = 32, 128

        preprocess_grid = (SEQ_LEN // BLOCK_SIZE_MACRO, BATCH_SIZE * NUM_HEADS)
        D = torch.empty_like(M)  # Shape: (BATCH_SIZE, NUM_HEADS, SEQ_LEN)

        # Compute all the elements Di
        _attn_bwd_preprocess[preprocess_grid](
            O=O,
            dO=dO,
            D=D,
            SEQ_LEN=SEQ_LEN,
            BLOCK_SIZE_Q=BLOCK_SIZE_MACRO,
            HEAD_DIM=ctx.HEAD_DIM,
        )

        grid = (SEQ_LEN // BLOCK_SIZE_MACRO, 1, BATCH_SIZE * NUM_HEADS)

        stage = 3 if ctx.causal else 1

        # Fix KV and iterate through all the Q blocks
        _attn_bwd_dk_dv[grid](
            Q=Q,
            K=K,
            V=V,
            softmax_scale=ctx.softmax_scale,
            dO=dO,
            dQ=dQ,
            dK=dK,
            dV=dV,
            M=M,
            D=D,
            stride_batch=Q.stride(0),
            stride_head=Q.stride(1),
            stride_seq=Q.stride(2),
            stride_dim=Q.stride(3),
            NUM_HEADS=NUM_HEADS,
            SEQ_LEN=SEQ_LEN,
            BLOCK_Q=BLOCK_SIZE_MICRO,
            BLOCK_KV=BLOCK_SIZE_MACRO,
            HEAD_DIM=ctx.HEAD_DIM,
            STAGE=stage,
            num_warps=NUM_WARPS,
            num_stages=NUM_STAGES,
        )

        # Fix Q and iterate through all the KV block
        _attn_bwd_dq[grid](
            Q=Q,
            K=K,
            V=V,
            softmax_scale=ctx.softmax_scale,
            dO=dO,
            dQ=dQ,
            dK=dK,
            dV=dV,
            M=M,
            D=D,
            stride_batch=Q.stride(0),
            stride_head=Q.stride(1),
            stride_seq=Q.stride(2),
            stride_dim=Q.stride(3),
            NUM_HEADS=NUM_HEADS,
            SEQ_LEN=SEQ_LEN,
            BLOCK_Q=BLOCK_SIZE_MACRO,
            BLOCK_KV=BLOCK_SIZE_MICRO,
            HEAD_DIM=ctx.HEAD_DIM,
            STAGE=stage,
            num_warps=NUM_WARPS,
            num_stages=NUM_STAGES,
        )

        return dQ, dK, dV, None, None


def test_op(BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM, causal, dtype=torch.float16):
    Q = (
        torch.empty(
            (BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM), dtype=dtype, device="cuda"
        )
        .normal_(mean=0.0, std=0.5)
        .requires_grad_()
    )
    K = (
        torch.empty(
            (BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM), dtype=dtype, device="cuda"
        )
        .normal_(mean=0.0, std=0.5)
        .requires_grad_()
    )
    V = (
        torch.empty(
            (BATCH_SIZE, NUM_HEADS, SEQ_LEN, HEAD_DIM), dtype=dtype, device="cuda"
        )
        .normal_(mean=0.0, std=0.5)
        .requires_grad_()
    )

    softmax_scale = 1 / (HEAD_DIM**0.5)
    dO = torch.randn_like(Q)

    # reference implementation
    MASK = torch.tril(torch.ones((SEQ_LEN, SEQ_LEN), device="cuda"))
    P = torch.matmul(Q, K.transpose(2, 3)) * softmax_scale
    if causal:
        P[:, :, MASK == 0] = float("-inf")
    P = torch.softmax(P.float(), dim=-1).half()
    ref_O = torch.matmul(P, V)
    ref_O.backward(dO)
    ref_dV, V.grad = V.grad.clone(), None
    ref_dK, K.grad = K.grad.clone(), None
    ref_dQ, Q.grad = Q.grad.clone(), None

    # triton implementation
    tri_out = TritonAttention.apply(Q, K, V, causal, softmax_scale).half()
    tri_out.backward(dO)
    tri_dV, V.grad = V.grad.clone(), None
    tri_dK, K.grad = K.grad.clone(), None
    tri_dQ, Q.grad = Q.grad.clone(), None

    # compare
    rtol = 0.0
    atol = 1e-2
    assert torch.allclose(ref_O, tri_out, atol=atol, rtol=rtol)
    assert torch.allclose(ref_dK, tri_dK, atol=atol, rtol=rtol)
    assert torch.allclose(ref_dV, tri_dV, atol=atol, rtol=rtol)
    assert torch.allclose(ref_dQ, tri_dQ, atol=atol, rtol=rtol)


if __name__ == "__main__":
    test_op(BATCH_SIZE=8, NUM_HEADS=16, SEQ_LEN=4096, HEAD_DIM=64, causal=True)
    test_op(BATCH_SIZE=8, NUM_HEADS=16, SEQ_LEN=4096, HEAD_DIM=64, causal=False)
    print("PASSED")




# ---- IMPORT YOUR TRITON ATTENTION ----
# (Paste the full TritonAttention implementation ABOVE this Transformer
#  exactly as you provided)

# ------------------------------------------------------------
# Multi-Head Attention Wrapper
# ------------------------------------------------------------
class MultiHeadTritonAttention(nn.Module):
    def __init__(self, d_model, num_heads, causal=True):
        super().__init__()
        assert d_model % num_heads == 0
        self.num_heads = num_heads
        self.head_dim = d_model // num_heads
        self.causal = causal

        self.qkv = nn.Linear(d_model, 3 * d_model, bias=False)
        self.out = nn.Linear(d_model, d_model, bias=False)

    def forward(self, x):
        B, T, C = x.shape
        qkv = self.qkv(x)
        q, k, v = qkv.chunk(3, dim=-1)

        q = q.view(B, T, self.num_heads, self.head_dim).transpose(1, 2)
        k = k.view(B, T, self.num_heads, self.head_dim).transpose(1, 2)
        v = v.view(B, T, self.num_heads, self.head_dim).transpose(1, 2)

        scale = 1.0 / math.sqrt(self.head_dim)

        out = TritonAttention.apply(q, k, v, self.causal, scale)

        out = out.transpose(1, 2).contiguous().view(B, T, C)
        return self.out(out)


# ------------------------------------------------------------
# Feed Forward Network
# ------------------------------------------------------------
class MLP(nn.Module):
    def __init__(self, d_model, hidden_dim):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(d_model, hidden_dim),
            nn.GELU(),
            nn.Linear(hidden_dim, d_model),
        )

    def forward(self, x):
        return self.net(x)


# ------------------------------------------------------------
# Transformer Block
# ------------------------------------------------------------
class TransformerBlock(nn.Module):
    def __init__(self, d_model, num_heads, mlp_ratio=4):
        super().__init__()
        self.ln1 = nn.LayerNorm(d_model)
        self.attn = MultiHeadTritonAttention(d_model, num_heads, causal=True)
        self.ln2 = nn.LayerNorm(d_model)
        self.mlp = MLP(d_model, d_model * mlp_ratio)

    def forward(self, x):
        x = x + self.attn(self.ln1(x))
        x = x + self.mlp(self.ln2(x))
        return x


# ------------------------------------------------------------
# GPT-style Decoder-only Transformer
# ------------------------------------------------------------
class TritonGPT(nn.Module):
    def __init__(self, vocab_size, d_model, num_layers, num_heads, max_seq_len):
        super().__init__()
        self.token_emb = nn.Embedding(vocab_size, d_model)
        self.pos_emb = nn.Parameter(torch.zeros(1, max_seq_len, d_model))

        self.blocks = nn.ModuleList([
            TransformerBlock(d_model, num_heads)
            for _ in range(num_layers)
        ])

        self.ln_f = nn.LayerNorm(d_model)
        self.lm_head = nn.Linear(d_model, vocab_size, bias=False)

    def forward(self, idx):
        B, T = idx.shape
        x = self.token_emb(idx) + self.pos_emb[:, :T, :]

        for block in self.blocks:
            x = block(x)

        x = self.ln_f(x)
        logits = self.lm_head(x)
        return logits


# ------------------------------------------------------------
# Example usage
# ------------------------------------------------------------
if __name__ == "__main__":
    model = TritonGPT(
        vocab_size=50257,
        d_model=768,
        num_layers=12,
        num_heads=12,
        max_seq_len=1024,
    ).cuda()

    dummy = torch.randint(0, 50257, (2, 512), device="cuda")
    out = model(dummy)
    print(out.shape)






*---------------------------not-working-----------------------
import torch.nn as nn
from torch.utils.data import Dataset
import torch.utils.data
import math
import pandas as pd
from torch.nn.utils.rnn import pad_sequence
from transformers import BertTokenizerFast
tokenizer = BertTokenizerFast.from_pretrained("bert-base-uncased")
import torch
from torch.utils.data import Dataset, DataLoader
import torch.nn.functional as F
import math
import triton
import triton.language as tl
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


max_len = 128
d_model = 256
heads = 8
num_layers =4
epochs = 2
Batch=128


def create_masks(question, reply_input, reply_target):
    def subsequent_mask(size):
        mask = torch.triu(torch.ones(size, size)).transpose(0, 1).type(dtype=torch.uint8)
        return mask.unsqueeze(0)
    question_mask = question != 0
    question_mask = question_mask.to(device)
    question_mask = question_mask.unsqueeze(1).unsqueeze(1)  # (batch_size, 1, 1, max_words)
    reply_input_mask = reply_input != 0
    reply_input_mask = reply_input_mask.unsqueeze(1)  # (batch_size, 1, max_words)
    reply_input_mask = reply_input_mask & subsequent_mask(reply_input.size(-1)).type_as(reply_input_mask.data)
    reply_input_mask = reply_input_mask.unsqueeze(1)  # (batch_size, 1, max_words, max_words)
    reply_target_mask = reply_target != 0  # (batch_size, max_words)
    return question_mask, reply_input_mask, reply_target_mask


class Embeddings(nn.Module):
    """
    Implements embeddings of the words and adds their positional encodings.
    """

    def __init__(self, vocab_size, d_model, max_len=128, num_layers=3):
        super(Embeddings, self).__init__()
        self.d_model = d_model
        self.dropout = nn.Dropout(0.1)
        self.embed = nn.Embedding(vocab_size, d_model)
        self.pe = self.create_positinal_encoding(max_len, self.d_model)  # (1, max_len, d_model)
        self.te = self.create_positinal_encoding(num_layers, self.d_model)  # (1, num_layers, d_model)
        self.dropout = nn.Dropout(0.1)

    def create_positinal_encoding(self, max_len, d_model):
        pe = torch.zeros(max_len, d_model).to(device)
        for pos in range(max_len):  # for each position of the word
            for i in range(0, d_model, 2):  # for each dimension of the each position
                pe[pos, i] = math.sin(pos / (10000 ** ((2 * i) / d_model)))
                pe[pos, i + 1] = math.cos(pos / (10000 ** ((2 * (i + 1)) / d_model)))
        pe = pe.unsqueeze(0)  # include the batch size
        return pe
    def forward(self, embedding, layer_idx):
        if layer_idx == 0:
            embedding = self.embed(embedding) * math.sqrt(self.d_model)
        embedding += self.pe[:,
                     :embedding.size(1)]  # pe will automatically be expanded with the same batch size as encoded_words
        # embedding: (batch_size, max_len, d_model), te: (batch_size, 1, d_model)
        embedding += self.te[:, layer_idx, :].unsqueeze(1).repeat(1, embedding.size(1), 1)
        embedding = self.dropout(embedding)
        return embedding



@triton.jit
def attention_tile_kernel(
    Q_ptr, K_ptr, V_ptr,
    out_ptr,
    N, D, num_tiles,
    TILE_N: tl.constexpr, TILE_D: tl.constexpr, CHUNK_D: tl.constexpr
):
    pid_bh = tl.program_id(0)  # batch*head
    pid_tq = tl.program_id(1)  # tile along sequence N

    # -------------------------------
    # Compute row indices for this til
    # -------------------------------
    start_q = pid_tq * TILE_N
    rn = start_q + tl.arange(0, TILE_N)[:, None]  # (TILE_N,1)
    cd = tl.arange(0, TILE_D)[None, :]            # (1, TILE_D)
    q_mask = (rn < N) & (cd < D)

    # -------------------------------
    # Step 1 & 2: Load Q/K tiles and compute Q@Kᵀ
    # -------------------------------
    acc = tl.zeros((TILE_N, TILE_N), dtype=tl.float32)

    for d_off in range(0, TILE_D, CHUNK_D):
        cd_sub = d_off + tl.arange(0, CHUNK_D)[None, :]
        mask_sub = (rn < N) & (cd_sub < D)

        q_sub = tl.load(Q_ptr + pid_bh * N * D + rn * D + cd_sub, mask=mask_sub, other=0.0).to(tl.float16)
        k_sub = tl.load(K_ptr + pid_bh * N * D + rn * D + cd_sub, mask=mask_sub, other=0.0).to(tl.float16)

        q_f32 = q_sub.to(tl.float32)
        k_f32 = k_sub.to(tl.float32)

        partial = tl.sum(q_f32[:, None, :] * k_f32[None, :, :], axis=2)
        # partial = tl.sum((q_sub[:, None, :] * k_sub[None, :, :]).to(tl.float32), axis=2)

        acc += partial
    # acc = acc.to(tl.float32)

    # -------------------------------
    # Step 3: Online row-wise softma
    # ------------------------------
    row_max = tl.max(acc, axis=1)
    exp_tile = tl.exp(acc - row_max[:, None])
    row_sum = tl.sum(exp_tile, axis=1)
    softmax_tile = exp_tile / row_sum[:, None]  # shape (TILE_N, TILE_N)

    # -------------------------------
    # Step 4: Multiply with V
    # -------------------------------
    # accumulator for output tile
    out_tile = tl.zeros((TILE_N, TILE_D), dtype=tl.float32)

    for d_off in range(0, D, CHUNK_D):
        cd_sub = d_off + tl.arange(0, CHUNK_D)[None, :]
        mask_sub = (rn < N) & (cd_sub < D)

        v_sub = tl.load(V_ptr + pid_bh * N * D + rn * D + cd_sub, mask=mask_sub, other=0.0).to(tl.float16)
        v_f32 = v_sub.to(tl.float32)  # (TILE_N, CHUNK_D)

        # Multiply softmax_tile (TILE_N × TILE_N) with V_chunk (TILE_N × CHUNK_D)
        # Result: TILE_N × CHUNK_D
        out_tile += tl.dot(softmax_tile, v_f32)  # Triton supports dot on small tiles

    # out_tile = out_tile.to(tl.float32)

    # -------------------------------
    # Store final output tile
    # -------------------------------
    out_idx = pid_bh * num_tiles * TILE_N * D \
             + pid_tq * TILE_N * D \
             + rn * D + cd  # linear offsets
    mask_out = (rn < N) & (cd < D)
    # tl.store(out_ptr + out_idx, out_tile, mask=mask_out)
    tl.store(out_ptr + out_idx, out_tile.to(tl.float16), mask=mask_out)


def flashattention_triton(q_tf, k_tf, v_tf, TILE_N=16, TILE_D=16, CHUNK_D=16):
    """
    q_tf, k_tf, v_tf : TensorFlow tensors with shape (B, H, N, D) and dtype float16 (or convertible)
    Returns TensorFlow tensor with shape (B, H, N, D) dtype float32 (matches kernel stores).
    """
    # print("r1")

    # Convert TF -> NumPy -> Torch (CUDA). Keep dtype consistent
    q = q_tf.to(device="cuda", dtype=torch.float16).contiguous()
    k = k_tf.to(device="cuda", dtype=torch.float16).contiguous()
    v = v_tf.to(device="cuda", dtype=torch.float16).contiguous()
    # q = torch.as_tensor(q_tf.numpy(), device='cuda').to(dtype=torch.float16)
    # k = torch.as_tensor(k_tf.numpy(), device='cuda').to(dtype=torch.float16)
    # v = torch.as_tensor(v_tf.numpy(), device='cuda').to(dtype=torch.float16)
    # q = torch.utils.dlpack.from_dlpack(tf.experimental.dlpack.to_dlpack(q_tf)).to(dtype=torch.float16).contiguous()
    # k = torch.utils.dlpack.from_dlpack(tf.experimental.dlpack.to_dlpack(k_tf)).to(dtype=torch.float16).contiguous()
    # v = torch.utils.dlpack.from_dlpack(tf.experimental.dlpack.to_dlpack(v_tf)).to(dtype=torch.float16).contiguous()
    # print("r2")
  
    B, H, N, D = q.shape
    BH = B * H

    num_tiles = (N + TILE_N - 1) // TILE_N
    padded_N = num_tiles * TILE_N   # may be >= N

    # Flatten B*H and pad sequence length if needed
    # print("r3")

    q_flat = q.reshape(BH, N, D)
    k_flat = k.reshape(BH, N, D)
    v_flat = v.reshape(BH, N, D)
    # print("v shape")
    # print(k_flat.shape)
    # print(v_flat.shape)

    # print("r4")
 

    # If padded_N > N, we must creat padded tensors (kernel reads up to rn < N via mask, so reading outside bounds is avoided,
    # but easier to pass tensors with shape (BH, padded_N, D) so store layout matches)
    if padded_N != N:
        # create padded views with zeros for rows N..padded_N-1
        q_pad = torch.zeros((BH, padded_N, D), device='cuda', dtype=q_flat.dtype)
        k_pad = torch.zeros((BH, padded_N, D), device='cuda', dtype=k_flat.dtype)
        v_pad = torch.zeros((BH, padded_N, D), device='cuda', dtype=v_flat.dtype)
        q_pad[:, :N, :] = q_flat
        k_pad[:, :N, :] = k_flat
        v_pad[:, :N, :] = v_flat
        q_flat = q_pad
        k_flat = k_pad
        v_flat = v_pad
    else:
        # ensure contiguous
        q_flat = q_flat.contiguous()
        k_flat = k_flat.contiguous()
        v_flat = v_flat.contiguous()

    # print("r5")


    # Allocate output as (BH, padded_N, D) in float32 (kernel stores float32
    # out_flat = torch.zeros((BH, padded_N, D), device='cuda', dtype=torch.float16, requires_grad=False).contiguous()
    out_flat = torch.zeros((BH, padded_N, D), device='cuda', dtype=torch.float32, requires_grad=False).contiguous()

    # print("r6")
    grid = (BH, num_tiles)

    # Call Triton kernel.
    # NOTE: attention_tile_kernel must be the Triton function you posted earlier (or the corrected chunking version).
    # Triton accepts torch tensors as args and will get underlying pointers automatically.
    attention_tile_kernel[grid](
        q_flat, k_flat, v_flat,
        out_flat,
        N, D, num_tiles,
        TILE_N, TILE_D, CHUNK_D
    )

    out_torch = out_flat[:, :N].reshape(B, H, N, D).contiguous()
    return out_torch  # NOW returning Py

    return out_tf

class MultiHeadAttention(nn.Module):
    def __init__(self, heads, d_model):
        super(MultiHeadAttention, self).__init__()
        assert d_model % heads == 0
        self.d_k = d_model // heads
        self.heads = heads
        self.dropout = nn.Dropout(0.1)
        self.query = nn.Linear(d_model, d_model)
        self.key = nn.Linear(d_model, d_model)
        self.value = nn.Linear(d_model, d_model)
        self.concat = nn.Linear(d_model, d_model)

    def forward(self, query, key, value, mask=None):
        # query/key/value: (B, seq_len, d_model) float32 by default
        B = query.shape[0]

        # Linear projections (stay in float32)
        q = self.query(query)
        k = self.key(key)
        v = self.value(value)

        # Reshape to (B, H, N, D)
        q = q.view(B, -1, self.heads, self.d_k).permute(0, 2, 1, 3).contiguous()
        k = k.view(B, -1, self.heads, self.d_k).permute(0, 2, 1, 3).contiguous()
        v = v.view(B, -1, self.heads, self.d_k).permute(0, 2, 1, 3).contiguous()

        # Call flashattention (requires float16/bf16 for best perf). We'll pass fp16 but convert back after.
        attn_out = flashattention_triton(q, k, v, TILE_N=32, TILE_D=32, CHUNK_D=32)
        # attn_out: (B, H, N, D) dtype=float16

        # Convert to float32 for the linear concat
        attn_out = attn_out.float()

        # Merge heads: (B, N, H*D)
        context = attn_out.permute(0, 2, 1, 3).contiguous().view(B, -1, self.heads * self.d_k)

        # Final linear
        out = self.concat(context)
        return out



class FeedForward(nn.Module):
    def __init__(self, d_model, middle_dim=2048):
            super(FeedForward, self).__init__()
            self.fc1 = nn.Linear(d_model, middle_dim)
            self.fc2 = nn.Linear(middle_dim, d_model)
            self.dropout = nn.Dropout(0.1)

    def forward(self, x):
            out = F.relu(self.fc1(x))
            out = self.fc2(self.dropout(out))
            return out

class EncoderLayer(nn.Module):
    def __init__(self, d_model, heads):
        super(EncoderLayer, self).__init__()
        self.layernorm = nn.LayerNorm(d_model)
        self.self_multihead = MultiHeadAttention(heads, d_model)
        self.feed_forward = FeedForward(d_model)
        self.dropout = nn.Dropout(0.1)

    def forward(self, embeddings, mask):
        interacted = self.dropout(self.self_multihead(embeddings, embeddings, embeddings, mask))
        interacted = self.layernorm(interacted + embeddings)
        feed_forward_out = self.dropout(self.feed_forward(interacted))
        encoded = self.layernorm(feed_forward_out + interacted)
        return encoded


class DecoderLayer(nn.Module):
    def __init__(self, d_model, heads):
        super(DecoderLayer, self).__init__()
        self.layernorm = nn.LayerNorm(d_model)
        self.self_multihead = MultiHeadAttention(heads, d_model)
        self.src_multihead = MultiHeadAttention(heads, d_model)
        self.feed_forward = FeedForward(d_model)
        self.dropout = nn.Dropout(0.1)
    def forward(self, embeddings, encoded, src_mask, target_mask):
        query = self.dropout(self.self_multihead(embeddings, embeddings, embeddings, target_mask))
        query = self.layernorm(query + embeddings)
        interacted = self.dropout(self.src_multihead(query, encoded, encoded, src_mask))
        interacted = self.layernorm(interacted + query)
        feed_forward_out = self.dropout(self.feed_forward(interacted))
        decoded = self.layernorm(feed_forward_out + interacted)
        return decoded


class Transformer(nn.Module):
    def __init__(self, d_model, heads, num_layers, word_map):
        super(Transformer, self).__init__()
        self.d_model = d_model
        self.num_layers = num_layers
        self.vocab_size = len(word_map)
        self.embed = Embeddings(self.vocab_size, d_model, num_layers=num_layers)
        self.encoder = EncoderLayer(d_model, heads)
        self.decoder = DecoderLayer(d_model, heads)
        self.logit = nn.Linear(d_model, self.vocab_size)

    def encode(self, src_embeddings, src_mask):
        for i in range(self.num_layers):
            src_embeddings = self.embed(src_embeddings, i)
            src_embeddings = self.encoder(src_embeddings, src_mask)
        return src_embeddings

    def decode(self, tgt_embeddings, target_mask, src_embeddings, src_mask):
        for i in range(self.num_layers):
            tgt_embeddings = self.embed(tgt_embeddings, i)
            # print("embeddings")
            # print(tgt_embeddings)
            tgt_embeddings = self.decoder(tgt_embeddings, src_embeddings, src_mask, target_mask)
        return tgt_embeddings

    def forward(self, src_words, src_mask, target_words, target_mask):
        encoded = self.encode(src_words, src_mask)
        decoded = self.decode(target_words, target_mask, encoded, src_mask)
        out = self.logit(decoded)
        return out

class AdamWarmup:
    def __init__(self, model_size, warmup_steps, optimizer):
        self.model_size = model_size
        self.warmup_steps = warmup_steps
        self.optimizer = optimizer
        self.current_step = 0
        self.lr = 0

    def get_lr(self):
        return self.model_size ** (-0.5) * min(self.current_step ** (-0.5),
                                               self.current_step * self.warmup_steps ** (-1.5))
    def step(self):
        # Increment the number of steps each time we call the step function
        self.current_step += 1
        lr = self.get_lr()
        for param_group in self.optimizer.param_groups:
            param_group['lr'] = lr
        # update the learning rate
        self.lr = lr
        self.optimizer.step()


class LossWithLS(nn.Module):
    def __init__(self, size, smooth, pad_token_id=-100):
        super().__init__()
        self.criterion = nn.KLDivLoss(reduction='batchmean')
        self.confidence = 1.0 - smooth
        self.smooth = smooth
        self.size = size
        self.pad_id = pad_token_id

    def forward(self, prediction, target, mask):
        # Flatten
        prediction = prediction.view(-1, prediction.size(-1))
        target = target.view(-1)
        mask = mask.float().view(-1)

        # ----- FIX: handle PAD tokens -----
        target_fixed = target.clone()
        target_fixed[target_fixed == self.pad_id] = 0  # dummy index for PAD

        # Label smoothing distribution
        labels = torch.full_like(prediction, self.smooth / (self.size - 1))
        labels.scatter_(1, target_fixed.unsqueeze(1), self.confidence)
        # print("lael")
        # print(labels)
        # print("predi")
        # print(prediction)

        # Compute KL divergence
        loss = self.criterion(prediction, labels).sum(1)

        # apply mask (PAD tokens removed)
        loss = (loss * mask).sum() / mask.sum()

        return loss


#---------------------------Bert -ec----------------------------------

import torch
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader
import pandas as pd

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")


# ================================================
# 1. LOAD CSV (1000 samples)
# ================================================
df = pd.read_csv("/kaggle/input/news-summarization/data.csv").head(3200)

contents  = df["Content"].astype(str).tolist()
summaries = df["Summary"].astype(str).tolist()


# ================================================
# 2. CUSTOM DATASET
# ================================================
class TextSummaryDataset(Dataset):
    def __init__(self, contents, summaries, tokenizer, max_len):
        self.contents = contents
        self.summaries = summaries
        self.tokenizer = tokenizer
        self.max_len = max_len
        self.pad = tokenizer.pad_token_id

    def __len__(self):
        return len(self.contents)

    def __getitem__(self, idx):
        content = self.contents[idx]
        summary = self.summaries[idx]

        # Encode input (Content)
        enc = self.tokenizer(
            content,
            padding='max_length', truncation=True,
            max_length=self.max_len,
            return_tensors='pt'
        )

        # Encode output (Summary)
        dec = self.tokenizer(
            summary,
            padding='max_length', truncation=True,
            max_length=self.max_len,
            return_tensors='pt'
        )

        # Tensors are shape (1, max_len) → remove dimension
        input_ids = enc['input_ids'].squeeze(0)
        summary_ids = dec['input_ids'].squeeze(0)

        # Decoder input (shift right)
        reply_input_ids = summary_ids[:-1]
        reply_input_ids = F.pad(reply_input_ids,
                                (0, self.max_len - reply_input_ids.size(0)),
                                value=self.pad)

        # Decoder target (shift left)
        reply_target_ids = summary_ids[1:]
        reply_target_ids = F.pad(reply_target_ids,
                                 (0, self.max_len - reply_target_ids.size(0)),
                                 value=self.pad)

        return {
            "question_ids": input_ids,
            "reply_input_ids": reply_input_ids,
            "reply_target_ids": reply_target_ids
        }


# ================================================
# 3. DATALOADER
# ================================================
dataset = TextSummaryDataset(contents, summaries, tokenizer, max_len)
loader = DataLoader(dataset, batch_size=64, shuffle=True)

# ================================================
# 4. INITIALIZE MODEL
# ================================================
dummy_vocab = tokenizer.get_vocab()
print(len(dummy_vocab))

model = Transformer(
    d_model=d_model,
    heads=heads,
    num_layers=num_layers,
    word_map=dummy_vocab
).to(device)

optimizer = torch.optim.Adam(model.parameters(), lr=2e-4)

criterion = LossWithLS(len(dummy_vocab), 0.2)

# ================================================
# 5. TRAINING LOOP (10 epochs)
# ================================================
loss_fn = torch.nn.CrossEntropyLoss(ignore_index=tokenizer.pad_token_id)
print("training.............")
epochs=1
for epoch in range(epochs):

    model.train()
    total_loss = 0

    for batch in loader:

        question_ids = batch["question_ids"].to(device)
        reply_input_ids = batch["reply_input_ids"].to(device)
        reply_target_ids = batch["reply_target_ids"].to(device)

        reply_target_ids_masked = reply_target_ids.clone()
        reply_target_ids_masked[reply_target_ids_masked == tokenizer.pad_token_id] = -100

        # Create masks
        q_mask, reply_input_mask, reply_target_mask = create_masks(
            question_ids, reply_input_ids, reply_target_ids
        )
        # print("question_ids:", question_ids.shape, question_ids.dtype, question_ids.min(), question_ids.max())
        # print("reply_input_ids:", reply_input_ids.shape, reply_input_ids.dtype, reply_input_ids.min(), reply_input_ids.max())
        # print("reply_target_ids:", reply_target_ids.shape, reply_target_ids.dtype, reply_target_ids.min(), reply_target_ids.max())
        optimizer.zero_grad()
        outputs = model(question_ids, q_mask, reply_input_ids, reply_input_mask)
        log_probs = F.log_softmax(outputs, dim=-1)
        # targets = reply_target_ids_masked.reshape(-1)
        # target_probs = F.one_hot(
        #     reply_target_ids_masked, 
        #     num_classes=vocab_size
        # ).float()
        
        # # Mask padding tokens
        # target_probs[reply_target_ids_masked == -100] = 0
        # loss = F.kl_div(
        #     log_probs,                     # shape [B,T,V], log-probs
        #     target_probs,                 # shape [B,T,V], probs
        #     reduction="batchmean"
        # )

        logits = outputs  # raw model outputs
        vocab_size = outputs.size(-1)        
        loss = F.cross_entropy(
            logits.reshape(-1, vocab_size),       # [B*T, V]
            reply_target_ids_masked.reshape(-1),  # [B*T], integers
            ignore_index=-100                     # ignore padding
        )
        # loss = criterion(log_probs, reply_target_ids, reply_target_mask)
        loss.backward()
        optimizer.step()
        print(loss.item())
        # total_loss += loss.item()
    if epoch == epochs - 1:
        state = {
            'epoch': epoch,
            'model_state_dict': model.state_dict(),
            'optimizer_state_dict': optimizer.state_dict()
        }
        torch.save(state, '/kaggle/working/checkpoint_last_epoch.pth.tar')  # Kaggle-safe path


    print(f"Epoch {epoch+1}/10   Loss: {total_loss:.4f}")


print("Training complete")

# def evaluate(transformer, question, question_mask, max_len, word_map):
#     """
#     Performs Greedy Decoding with a batch size of 1
#     """
#     rev_word_map = {v: k for k, v in word_map.items()}
#     transformer.eval()
#     print("Is in evaluation mode:", not transformer.training)
#     start_token = word_map['<start>']
#     encoded = transformer.encode(question, question_mask)
#     words = torch.LongTensor([[start_token]]).to(device)

#     for step in range(max_len - 1):
#         size = words.shape[1]
#         target_mask = torch.triu(torch.ones(size, size)).transpose(0, 1).type(dtype=torch.uint8)
#         target_mask = target_mask.to(device).unsqueeze(0).unsqueeze(0)
#         decoded = transformer.decode(words, target_mask, encoded, question_mask)
#         predictions = transformer.logit(decoded[:, -1])
#         _, next_word = torch.max(predictions, dim=1)
#         next_word = next_word.item()
#         if next_word == word_map['<end>']:
#             break
#         words = torch.cat([words, torch.LongTensor([[next_word]]).to(device)], dim=1)  # (1,step+2)
#         # Construct Sentence
#     if words.dim() == 2:
#             words = words.squeeze(0)
#             words = words.tolist()

#     sen_idx = [w for w in words if w not in {word_map['<start>']}]
#     sentence = ' '.join([rev_word_map[sen_idx[k]] for k in range(len(sen_idx))])

#     return sentence

def evaluate(transformer, question_ids, question_mask, max_len, word_map):
    """
    Greedy decoding for batch size = 1 using BERT tokenizer mapping.
    """
    transformer.eval()
    print("Is in evaluation mode:", not transformer.training)
    
    start_token = word_map['<start>']
    end_token   = word_map['<end>']
    
    # Encode the input
    encoded = transformer.encode(question_ids, question_mask)
    
    # Initialize output sequence with start token
    words = torch.LongTensor([[start_token]]).to(question_ids.device)

    for step in range(max_len - 1):
        size = words.shape[1]

        # Causal mask for decoder
        target_mask = torch.triu(torch.ones(size, size)).transpose(0, 1).type(torch.uint8)
        target_mask = target_mask.to(question_ids.device).unsqueeze(0).unsqueeze(0)

        # Decode
        decoded = transformer.decode(words, target_mask, encoded, question_mask)
        predictions = transformer.logit(decoded[:, -1])  # logits for last token

        # Pick next token (greedy)
        _, next_word = torch.max(predictions, dim=1)
        next_word = next_word.item()

        if next_word == end_token:
            break

        words = torch.cat([words, torch.LongTensor([[next_word]]).to(question_ids.device)], dim=1)

    # Convert token IDs to words
    words = words.squeeze(0).tolist()  # flatten to list
    sen_idx = [w for w in words if w not in {start_token}]
    sentence = ' '.join([rev_word_map[w] for w in sen_idx])

    # Clean up BERT tokens
    sentence = sentence.replace(" ##", "")  # merge wordpieces
    sentence = sentence.replace("[PAD]", "").strip()

    return sentence

word_map1 = tokenizer.get_vocab()  # token -> id mapping
# Map start and end tokens
word_map1['<start>'] = tokenizer.cls_token_id  # [CLS]
word_map1['<end>'] = tokenizer.sep_token_id    # [SEP]

rev_word_map = {v: k for k, v in word_map1.items()}  # id -> token mapping

transformer = model.to(device)

# Create optimizer wrapper
adam_optimizer = torch.optim.Adam(transformer.parameters(), lr=0, betas=(0.9, 0.98), eps=1e-9)
transformer_optimizer = AdamWarmup(model_size=d_model, warmup_steps=4000, optimizer=adam_optimizer)

# Load checkpoint

checkpoint = torch.load('/kaggle/working/checkpoint_last_epoch.pth.tar', map_location=device)
transformer.load_state_dict(checkpoint['model_state_dict'])
transformer_optimizer.optimizer.load_state_dict(checkpoint['optimizer_state_dict'])
epoch = checkpoint['epoch']

print(f"Loaded checkpoint from epoch {epoch}")
question ="This is a big passage. Please summarize it in short so that users should be able to understand it very clearly\n"

# Tokenize using BERT tokenizer
max_len = 100
tokens = tokenizer(question, 
                   max_length=max_len, 
                   padding='max_length', 
                   truncation=True, 
                   return_tensors='pt')

# Move inputs to device
question_ids = tokens['input_ids'].to(device)           # shape: [1, max_len]
question_mask = tokens['attention_mask'].to(device)    # shape: [1, max_len]

# Adjust mask shape if your model expects (batch, 1, 1, seq_len)
question_mask = question_mask.unsqueeze(1).unsqueeze(1)  # shape: [1, 1, 1, max_len]

# Generate output using your transformer
sentence = evaluate(transformer, question_ids, question_mask, int(max_len), word_map1)
print(sentence)
